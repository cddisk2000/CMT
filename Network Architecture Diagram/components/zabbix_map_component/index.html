<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Zabbix Map Component</title>
    <style>
      :root {
        color-scheme: dark;
      }
      body {
        margin: 0;
        font-family: "Segoe UI", Arial, sans-serif;
        background: transparent;
        color: #fef3c7;
      }
      #wrapper {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      #palette {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 6px 4px;
      }
      .palette-item {
        padding: 6px 10px;
        background: linear-gradient(135deg, rgba(120, 53, 15, 0.6), rgba(30, 41, 59, 0.7));
        border: 1px solid rgba(251, 146, 60, 0.5);
        border-radius: 10px;
        color: #fde68a;
        font-size: 12px;
        cursor: grab;
        user-select: none;
        text-transform: uppercase;
        letter-spacing: 0.06em;
      }
      .palette-item:active {
        cursor: grabbing;
      }
      #hint {
        font-size: 11px;
        color: #fcd34d;
        padding-left: 4px;
      }
      #canvas {
        border: 1px solid rgba(251, 146, 60, 0.35);
        border-radius: 14px;
        background: radial-gradient(circle at top left, rgba(120, 53, 15, 0.22), transparent 60%),
          radial-gradient(circle at bottom right, rgba(249, 115, 22, 0.18), transparent 55%),
          rgba(2, 6, 23, 0.45);
        overflow: hidden;
        position: relative;
      }
      svg {
        display: block;
      }
      .edge {
        stroke: rgba(251, 146, 60, 0.55);
        stroke-width: 2.4;
        fill: none;
      }
      .group-rect {
        fill: rgba(251, 146, 60, 0.08);
        stroke: rgba(251, 146, 60, 0.4);
        stroke-width: 1;
        rx: 12;
      }
      .group-label {
        font-size: 11px;
        fill: #fde68a;
      }
      .node-label {
        fill: #fef3c7;
        font-size: 12px;
        text-anchor: start;
        dominant-baseline: middle;
        pointer-events: none;
        font-weight: 600;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.45);
      }
      .node-label .title-line {
        font-size: 13px;
        font-weight: 700;
        fill: #fff7ed;
      }
      .node-label .status-line {
        font-size: 10px;
        font-weight: 600;
        letter-spacing: 0.01em;
      }
      .node-label .status-up {
        fill: #22c55e;
      }
      .node-label .status-degraded {
        fill: #f59e0b;
      }
      .node-label .status-down {
        fill: #ef4444;
      }
      .node-label .status-unknown {
        fill: #94a3b8;
      }
      .node-label .avg-line {
        font-size: 9px;
        fill: #cbd5f5;
        font-weight: 500;
        letter-spacing: 0.01em;
      }
      .node-label .ip-line {
        font-size: 11px;
        fill: #bae6fd;
        font-weight: 600;
        letter-spacing: 0.01em;
      }
      .node-icon {
        font-size: 10px;
        font-weight: 700;
        fill: #111827;
        text-anchor: middle;
        dominant-baseline: middle;
        pointer-events: none;
      }
      #context-menu {
        position: fixed;
        display: none;
        flex-direction: column;
        gap: 6px;
        background: rgba(15, 23, 42, 0.98);
        border: 1px solid rgba(251, 146, 60, 0.5);
        border-radius: 10px;
        padding: 8px;
        z-index: 1000;
        box-shadow: 0 12px 28px rgba(0, 0, 0, 0.4);
      }
      #context-menu button {
        border: 1px solid rgba(251, 146, 60, 0.35);
        background: rgba(30, 41, 59, 0.9);
        color: #fde68a;
        border-radius: 8px;
        padding: 6px 10px;
        font-size: 12px;
        cursor: pointer;
        text-align: left;
      }
      #context-menu button:hover {
        background: rgba(251, 146, 60, 0.2);
      }
      #overlay {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(2, 6, 23, 0.55);
        z-index: 1001;
      }
      #overlay.open {
        display: flex;
      }
      .modal {
        width: min(520px, 92vw);
        background: rgba(15, 23, 42, 0.98);
        border: 1px solid rgba(251, 146, 60, 0.4);
        border-radius: 16px;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.5);
        padding: 18px 18px 16px;
        color: #e2e8f0;
      }
      .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
      }
      .modal-header h3 {
        margin: 0;
        font-size: 18px;
        font-weight: 700;
        color: #f8fafc;
      }
      .modal-close {
        background: transparent;
        border: none;
        color: #f8fafc;
        font-size: 20px;
        cursor: pointer;
      }
      .modal-body label {
        display: block;
        margin: 10px 0 6px;
        font-size: 12px;
        color: #cbd5f5;
      }
      .modal-body input,
      .modal-body select,
      .modal-body textarea {
        width: 100%;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(30, 41, 59, 0.9);
        color: #f1f5f9;
        font-size: 13px;
        outline: none;
      }
      .modal-body textarea {
        min-height: 90px;
        resize: vertical;
      }
      .modal-actions {
        display: flex;
        gap: 10px;
        margin-top: 16px;
      }
      .modal-actions button {
        flex: 1;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(30, 41, 59, 0.9);
        color: #f1f5f9;
        cursor: pointer;
        font-weight: 600;
      }
      .modal-actions .primary {
        background: linear-gradient(135deg, #f59e0b, #fb923c);
        color: #111827;
        border: none;
      }
      .modal-actions .danger {
        background: rgba(239, 68, 68, 0.9);
        color: #fff;
        border: none;
      }
      #delete-confirm {
        display: none;
        margin-top: 6px;
        color: #fca5a5;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div id="wrapper">
      <div id="palette"></div>
      <div id="hint">Drag a node type into the canvas to create it.</div>
      <div id="canvas">
        <svg id="svg"></svg>
      </div>
    </div>
    <div id="context-menu">
      <button data-action="edit">Edit</button>
      <button data-action="delete">Delete</button>
    </div>
    <div id="overlay">
      <div class="modal">
        <div class="modal-header">
          <h3 id="modal-title">Edit node</h3>
          <button class="modal-close" id="modal-close" type="button">Ã—</button>
        </div>
        <div class="modal-body" id="modal-body">
          <label for="edit-type">Type</label>
          <select id="edit-type"></select>
          <div id="name-row">
            <label for="edit-name" id="name-label">Name</label>
            <input id="edit-name" type="text" />
          </div>
          <div id="text-row">
            <label for="edit-text">Text</label>
            <textarea id="edit-text"></textarea>
          </div>
          <div id="ip-row">
            <label for="edit-ip">IP</label>
            <input id="edit-ip" type="text" />
          </div>
          <label for="edit-floor">Floor</label>
          <select id="edit-floor"></select>
          <div id="delete-confirm">Delete this node and its edges?</div>
        </div>
        <div class="modal-actions">
          <button id="modal-create" class="primary" type="button">Create</button>
          <button id="modal-save" class="primary" type="button">Save</button>
          <button id="modal-delete" class="danger" type="button">Delete</button>
          <button id="modal-cancel" type="button">Cancel</button>
        </div>
      </div>
    </div>

    <script>
      let lastArgs = {};
      let dragging = null;
      let linking = null;
      let resizing = null;
      let selectedNodeId = null;
      let contextNodeId = null;
      let editState = { open: false, nodeId: null, mode: "edit", position: null };
      let nodePositions = {};
      let nodeSizes = {};
      let lastNodes = [];
      const defaultNodeSize = { w: 170, h: 92 };
      const minNodeSize = { w: 120, h: 68 };
      const maxNodeSize = { w: 320, h: 200 };

      function sendMessage(type, payload) {
        window.parent.postMessage(
          Object.assign({ isStreamlitMessage: true, type }, payload || {}),
          "*"
        );
      }

      function setFrameHeight(height) {
        sendMessage("streamlit:setFrameHeight", { height });
      }

      function setComponentValue(value) {
        sendMessage("streamlit:setComponentValue", { value });
      }

      function renderPalette(palette, typeLabels) {
        const paletteEl = document.getElementById("palette");
        paletteEl.innerHTML = "";
        (palette || []).forEach((type) => {
          const item = document.createElement("div");
          item.className = "palette-item";
          item.draggable = true;
          item.dataset.nodeType = type;
          item.textContent = (typeLabels && typeLabels[type]) || type;
          item.addEventListener("dragstart", (event) => {
            event.dataTransfer.setData("text/plain", type);
          });
          paletteEl.appendChild(item);
        });
      }

      function layoutGroups(nodes, groupNodes) {
        const groups = {};
        groupNodes.forEach((group) => {
          groups[group.id] = { ...group, bounds: null, children: [] };
        });
        nodes.forEach((node) => {
          if (node.parent && groups[node.parent]) {
            groups[node.parent].children.push(node);
          }
        });
        Object.values(groups).forEach((group) => {
          if (group.parent && groups[group.parent]) {
            groups[group.parent].children.push(group);
          }
        });

        function boundsFor(child) {
          if (child.bounds) {
            return child.bounds;
          }
          if (child.x !== undefined && child.y !== undefined) {
            return {
              minX: child.x - (child.w || defaultNodeSize.w) / 2,
              maxX: child.x + (child.w || defaultNodeSize.w) / 2,
              minY: child.y - (child.h || defaultNodeSize.h) / 2,
              maxY: child.y + (child.h || defaultNodeSize.h) / 2,
            };
          }
          if (!child.children || child.children.length === 0) {
            return null;
          }
          let bounds = null;
          child.children.forEach((inner) => {
            const innerBounds = boundsFor(inner);
            if (!innerBounds) return;
            if (!bounds) {
              bounds = { ...innerBounds };
            } else {
              bounds.minX = Math.min(bounds.minX, innerBounds.minX);
              bounds.maxX = Math.max(bounds.maxX, innerBounds.maxX);
              bounds.minY = Math.min(bounds.minY, innerBounds.minY);
              bounds.maxY = Math.max(bounds.maxY, innerBounds.maxY);
            }
          });
          if (!bounds) return null;
          const pad = 24;
          child.bounds = {
            minX: bounds.minX - pad,
            maxX: bounds.maxX + pad,
            minY: bounds.minY - pad,
            maxY: bounds.maxY + pad,
          };
          return child.bounds;
        }

        Object.values(groups).forEach((group) => {
          boundsFor(group);
        });
        return groups;
      }

      function createSvgElement(tag, attrs) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
        Object.entries(attrs || {}).forEach(([key, val]) => {
          if (val !== undefined && val !== null) {
            el.setAttribute(key, val);
          }
        });
        return el;
      }

      function drawNode(svg, node) {
        const group = createSvgElement("g", { "data-node-id": node.id });
        group.style.cursor = "grab";
        group.addEventListener("pointerdown", (event) => {
          if (event.shiftKey) {
            linking = { sourceId: node.id };
            event.preventDefault();
            return;
          }
          if (resizing) return;
          dragging = { id: node.id, offsetX: node.x - event.clientX, offsetY: node.y - event.clientY };
          group.setPointerCapture(event.pointerId);
        });
        group.addEventListener("dblclick", (event) => {
          event.preventDefault();
          openEdit(node.id);
        });
        group.addEventListener("contextmenu", (event) => {
          event.preventDefault();
          contextNodeId = node.id;
          showContextMenu(event.clientX, event.clientY);
        });
        group.addEventListener("pointerup", (event) => {
          if (linking) {
            const target = getNodeAtPosition(event.clientX, event.clientY);
            if (target && target.id !== linking.sourceId) {
              setComponentValue({
                event: "link",
                source_id: linking.sourceId,
                target_id: target.id,
              });
            }
            linking = null;
            removeTempLinkLine();
            return;
          }
          if (!dragging || dragging.id !== node.id) return;
          dragging = null;
          group.releasePointerCapture(event.pointerId);
          setComponentValue({
            event: "dragstop",
            selected_node_id: node.id,
            position: { x: node.x, y: node.y },
          });
        });
        group.addEventListener("click", () => {
          selectedNodeId = node.id;
          setComponentValue({
            event: "select",
            selected_node_id: node.id,
            position: { x: node.x, y: node.y },
          });
        });

        const fill = node.color || "#64748b";
        const stroke = "rgba(251, 146, 60, 0.85)";
        const w = node.w || defaultNodeSize.w;
        const h = node.h || defaultNodeSize.h;
        group.appendChild(
          createSvgElement("rect", {
            x: node.x - w / 2,
            y: node.y - h / 2,
            width: w,
            height: h,
            rx: 16,
            fill,
            stroke,
            "stroke-width": 1.2,
            filter: "url(#nodeGlow)",
          })
        );

      const iconMap = {
        router: "R",
        firewall: "FW",
        switch: "SW",
        core_switch: "CS",
        server: "SV",
        vm: "VM",
        storage: "ST",
        wireless_ap: "AP",
        cloud: "CL",
        cloud_vps: "CV",
        domain: "DN",
        text: "TX",
      };
        const iconText = iconMap[node.nodeType] || "N";
        group.appendChild(
          createSvgElement("circle", {
            cx: node.x - w / 2 + 14,
            cy: node.y - h / 2 + 14,
            r: 10,
            fill: "#fde68a",
          })
        );
        const icon = createSvgElement("text", {
          x: node.x - w / 2 + 14,
          y: node.y - h / 2 + 14,
          class: "node-icon",
        });
        icon.textContent = iconText;
        group.appendChild(icon);

        const label = createSvgElement("text", { x: node.x - w / 2 + 26, y: node.y, class: "node-label" });
        const lines = String(node.label || "").split("\n");
        const lineHeight = 14;
        const ipRegex = /^(?:\d{1,3}\.){3}\d{1,3}(?:\/\d{1,2})?$|:/;
        lines.forEach((line, idx) => {
          const tspan = createSvgElement("tspan", { x: node.x - w / 2 + 26, y: node.y + (idx - (lines.length - 1) / 2) * lineHeight });
          const text = String(line || "").trim();
          const firstWord = text.split(/\s+/)[0].toLowerCase();
          if (idx === 0) {
            tspan.setAttribute("class", "title-line");
          } else if (text.toLowerCase().startsWith("avg")) {
            tspan.setAttribute("class", "avg-line");
          } else if (["up", "degraded", "down"].includes(firstWord)) {
            const statusClass = `status-${firstWord}`;
            tspan.setAttribute("class", `status-line ${statusClass}`);
          } else if (ipRegex.test(text)) {
            tspan.setAttribute("class", "ip-line");
          }
          tspan.textContent = line;
          label.appendChild(tspan);
        });
        group.appendChild(label);
        svg.appendChild(group);

        if (selectedNodeId === node.id) {
          drawHandles(svg, node, w, h);
        }
      }

      function render(args) {
        lastArgs = args || {};
        const elements = lastArgs.elements || [];
        const palette = lastArgs.palette || [];
        const typeLabels = lastArgs.type_labels || {};
        const width = lastArgs.width || document.body.clientWidth || 800;
        const height = lastArgs.height || 600;

        renderPalette(palette, typeLabels);

        const canvas = document.getElementById("canvas");
        const svg = document.getElementById("svg");
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        svg.setAttribute("width", width);
        svg.setAttribute("height", height);
        svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
        svg.innerHTML = "";
        const defs = createSvgElement("defs");
        const filter = createSvgElement("filter", { id: "nodeGlow", x: "-30%", y: "-30%", width: "160%", height: "160%" });
        filter.appendChild(createSvgElement("feDropShadow", { dx: "0", dy: "2", stdDeviation: "4", floodColor: "#f59e0b", floodOpacity: "0.35" }));
        filter.appendChild(createSvgElement("feDropShadow", { dx: "0", dy: "0", stdDeviation: "6", floodColor: "#fb923c", floodOpacity: "0.35" }));
        defs.appendChild(filter);
        svg.appendChild(defs);

        const nodes = [];
        const groupNodes = [];
        const edges = [];
        elements.forEach((el) => {
          if (el.data && el.data.source && el.data.target) {
            edges.push(el);
          } else if (el.data && (el.data.parent || String(el.data.id || "").startsWith("group:"))) {
            groupNodes.push({ id: el.data.id, label: el.data.label || "", parent: el.data.parent });
          } else if (el.data) {
            const pos = el.position || { x: 0, y: 0 };
            nodes.push({
              id: el.data.id,
              label: el.data.label,
              color: el.data.color,
              shape: el.data.shape,
              nodeType: el.data.node_type || "",
              parent: el.data.parent,
              w: el.data.size_w,
              h: el.data.size_h,
              x: pos.x || 0,
              y: pos.y || 0,
            });
          }
        });

        nodes.forEach((node) => {
          if (nodePositions[node.id]) {
            node.x = nodePositions[node.id].x;
            node.y = nodePositions[node.id].y;
          }
          if (nodeSizes[node.id]) {
            node.w = nodeSizes[node.id].w;
            node.h = nodeSizes[node.id].h;
          }
          if (!node.w) node.w = defaultNodeSize.w;
          if (!node.h) node.h = defaultNodeSize.h;
        });

        const groups = layoutGroups(nodes, groupNodes);
        Object.values(groups).forEach((group) => {
          if (!group.bounds) return;
          const rect = createSvgElement("rect", {
            x: group.bounds.minX,
            y: group.bounds.minY,
            width: group.bounds.maxX - group.bounds.minX,
            height: group.bounds.maxY - group.bounds.minY,
            class: "group-rect",
          });
          svg.appendChild(rect);
          const label = createSvgElement("text", {
            x: group.bounds.minX + 8,
            y: group.bounds.minY + 16,
            class: "group-label",
          });
          label.textContent = group.label || group.id;
          svg.appendChild(label);
        });

        edges.forEach((edge) => {
          const src = nodes.find((n) => n.id === edge.data.source);
          const tgt = nodes.find((n) => n.id === edge.data.target);
          if (!src || !tgt) return;
          const line = createSvgElement("line", {
            x1: src.x,
            y1: src.y,
            x2: tgt.x,
            y2: tgt.y,
            class: "edge",
            stroke: edge.data.color || "rgba(148, 163, 184, 0.7)",
          });
          svg.appendChild(line);
        });

        lastNodes = nodes.map((node) => ({ ...node }));
        nodes.forEach((node) => drawNode(svg, node));

        const totalHeight =
          height +
          (document.getElementById("palette").offsetHeight || 0) +
          (document.getElementById("hint").offsetHeight || 0) +
          24;
        setFrameHeight(totalHeight);
      }

      document.getElementById("canvas").addEventListener("dragover", (event) => {
        event.preventDefault();
      });
      document.getElementById("canvas").addEventListener("drop", (event) => {
        event.preventDefault();
        const nodeType = event.dataTransfer.getData("text/plain");
        if (!nodeType) return;
        const rect = event.currentTarget.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        openCreate(nodeType, { x, y });
      });
      document.getElementById("svg").addEventListener("pointermove", (event) => {
        if (!dragging) return;
        const nodeId = dragging.id;
        const x = event.clientX + dragging.offsetX;
        const y = event.clientY + dragging.offsetY;
        nodePositions[nodeId] = { x, y };
        render(lastArgs);
      });
      document.getElementById("svg").addEventListener("pointermove", (event) => {
        if (!linking) return;
        drawTempLinkLine(event.clientX, event.clientY);
      });
      document.getElementById("svg").addEventListener("pointermove", (event) => {
        if (!resizing) return;
        const rect = document.getElementById("canvas").getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const dx = Math.abs(x - resizing.cx);
        const dy = Math.abs(y - resizing.cy);
        const scale = Math.max(dx / (resizing.w0 / 2), dy / (resizing.h0 / 2));
        const newW = Math.max(minNodeSize.w, Math.min(maxNodeSize.w, resizing.w0 * scale));
        const newH = Math.max(minNodeSize.h, Math.min(maxNodeSize.h, resizing.h0 * scale));
        nodeSizes[resizing.id] = { w: newW, h: newH };
        render(lastArgs);
      });
      document.getElementById("svg").addEventListener("pointerup", () => {
        if (!resizing) return;
        const size = nodeSizes[resizing.id] || { w: resizing.w0, h: resizing.h0 };
        setComponentValue({
          event: "resize",
          node_id: resizing.id,
          size: { w: size.w, h: size.h },
        });
        resizing = null;
      });

      function getNodeAtPosition(clientX, clientY) {
        const canvas = document.getElementById("canvas");
        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        const hit = lastNodes.find((node) => {
          const dx = Math.abs(node.x - x);
          const dy = Math.abs(node.y - y);
          return dx <= (node.w || defaultNodeSize.w) / 2 && dy <= (node.h || defaultNodeSize.h) / 2;
        });
        return hit || null;
      }

      function drawTempLinkLine(clientX, clientY) {
        const svg = document.getElementById("svg");
        let line = document.getElementById("temp-link-line");
        const canvas = document.getElementById("canvas");
        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        const source = lastNodes.find((n) => n.id === linking.sourceId);
        if (!source) return;
        if (!line) {
          line = createSvgElement("line", {
            id: "temp-link-line",
            x1: source.x,
            y1: source.y,
            x2: x,
            y2: y,
            class: "edge",
          });
          svg.appendChild(line);
        } else {
          line.setAttribute("x1", source.x);
          line.setAttribute("y1", source.y);
          line.setAttribute("x2", x);
          line.setAttribute("y2", y);
        }
      }

      function removeTempLinkLine() {
        const line = document.getElementById("temp-link-line");
        if (line && line.parentNode) {
          line.parentNode.removeChild(line);
        }
      }

      function drawHandles(svg, node, w, h) {
        const handleSize = 6;
        const corners = [
          { x: node.x - w / 2, y: node.y - h / 2 },
          { x: node.x + w / 2, y: node.y - h / 2 },
          { x: node.x - w / 2, y: node.y + h / 2 },
          { x: node.x + w / 2, y: node.y + h / 2 },
        ];
        corners.forEach((pt) => {
          const handle = createSvgElement("circle", {
            cx: pt.x,
            cy: pt.y,
            r: handleSize,
            fill: "#f8fafc",
            stroke: "#f59e0b",
            "stroke-width": 2,
          });
          handle.style.cursor = "nwse-resize";
          handle.addEventListener("pointerdown", (event) => {
            event.preventDefault();
            event.stopPropagation();
            const rect = document.getElementById("canvas").getBoundingClientRect();
            const px = event.clientX - rect.left;
            const py = event.clientY - rect.top;
            resizing = {
              id: node.id,
              cx: node.x,
              cy: node.y,
              w0: w,
              h0: h,
              px0: px,
              py0: py,
            };
          });
          svg.appendChild(handle);
        });
      }

      function showContextMenu(x, y) {
        const menu = document.getElementById("context-menu");
        menu.style.left = x + "px";
        menu.style.top = y + "px";
        menu.style.display = "flex";
      }

      function hideContextMenu() {
        const menu = document.getElementById("context-menu");
        menu.style.display = "none";
      }

      document.getElementById("context-menu").addEventListener("click", (event) => {
        const action = event.target && event.target.dataset ? event.target.dataset.action : null;
        if (!action || !contextNodeId) return;
        if (action === "edit") {
          openEdit(contextNodeId);
        } else if (action === "delete") {
          openDelete(contextNodeId);
        }
        hideContextMenu();
      });

      document.addEventListener("click", (event) => {
        if (!event.target.closest || !event.target.closest("#context-menu")) {
          hideContextMenu();
        }
      });

      function getNodeDataById(nodeId) {
        const list = lastArgs.node_data || [];
        return list.find((node) => node.id === nodeId);
      }

      function populateSelect(selectEl, options, current) {
        selectEl.innerHTML = "";
        (options || []).forEach((opt) => {
          const option = document.createElement("option");
          option.value = opt;
          option.textContent = opt;
          if (opt === current) {
            option.selected = true;
          }
          selectEl.appendChild(option);
        });
      }

      function setOverlayOpen(open) {
        const overlay = document.getElementById("overlay");
        editState.open = open;
        overlay.classList.toggle("open", open);
        if (!open) {
          editState.mode = "edit";
          editState.position = null;
        }
      }

      function setModeUI(mode) {
        const showCreate = mode === "create";
        const showEdit = mode === "edit";
        const showDelete = mode === "delete";
        document.getElementById("modal-create").style.display = showCreate ? "inline-block" : "none";
        document.getElementById("modal-save").style.display = showEdit ? "inline-block" : "none";
        document.getElementById("modal-delete").style.display = showDelete || showEdit ? "inline-block" : "none";
      }

      function updateFieldVisibility() {
        const typeValue = document.getElementById("edit-type").value;
        const ipRow = document.getElementById("ip-row");
        const nameLabel = document.getElementById("name-label");
        const nameRow = document.getElementById("name-row");
        const textRow = document.getElementById("text-row");
        if (typeValue === "domain") {
          ipRow.style.display = "none";
          nameLabel.textContent = "Domain";
          nameRow.style.display = "block";
          textRow.style.display = "none";
        } else {
          nameLabel.textContent = "Name";
          if (typeValue === "text") {
            ipRow.style.display = "none";
            textRow.style.display = "block";
            nameRow.style.display = "none";
            nameLabel.textContent = "Text";
          } else {
            ipRow.style.display = "block";
            textRow.style.display = "none";
            nameRow.style.display = "block";
          }
        }
      }

      function getNameValue() {
        const typeValue = document.getElementById("edit-type").value;
        if (typeValue === "text") {
          return document.getElementById("edit-text").value;
        }
        return document.getElementById("edit-name").value;
      }

      function openEdit(nodeId) {
        const node = getNodeDataById(nodeId);
        if (!node) return;
        const typeSelect = document.getElementById("edit-type");
        const floorSelect = document.getElementById("edit-floor");
        populateSelect(typeSelect, lastArgs.node_types || [], node.node_type || "");
        populateSelect(floorSelect, lastArgs.floor_options || [], node.floor || "");
        document.getElementById("edit-name").value = node.name || "";
        document.getElementById("edit-text").value = node.name || "";
        document.getElementById("edit-ip").value = node.ip || "";
        document.getElementById("modal-title").textContent = "Edit node";
        document.getElementById("delete-confirm").style.display = "none";
        setModeUI("edit");
        editState.nodeId = nodeId;
        editState.mode = "edit";
        editState.position = null;
        updateFieldVisibility();
        setOverlayOpen(true);
      }

      function openDelete(nodeId) {
        const node = getNodeDataById(nodeId);
        if (!node) return;
        const typeSelect = document.getElementById("edit-type");
        const floorSelect = document.getElementById("edit-floor");
        populateSelect(typeSelect, lastArgs.node_types || [], node.node_type || "");
        populateSelect(floorSelect, lastArgs.floor_options || [], node.floor || "");
        document.getElementById("edit-name").value = node.name || "";
        document.getElementById("edit-ip").value = node.ip || "";
        document.getElementById("modal-title").textContent = "Delete node";
        document.getElementById("delete-confirm").style.display = "block";
        setModeUI("delete");
        editState.nodeId = nodeId;
        editState.mode = "delete";
        editState.position = null;
        updateFieldVisibility();
        setOverlayOpen(true);
      }

      function openCreate(nodeType, position) {
        const typeSelect = document.getElementById("edit-type");
        const floorSelect = document.getElementById("edit-floor");
        populateSelect(typeSelect, lastArgs.node_types || [], nodeType || "");
        populateSelect(floorSelect, lastArgs.floor_options || [], (lastArgs.floor_options || [])[0] || "");
        const typeValue = typeSelect.value || nodeType || "";
        const defaultName =
          typeValue === "domain"
            ? ""
            : typeValue
              ? `New ${typeValue.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase())}`
              : "New Node";
        document.getElementById("edit-name").value = defaultName;
        document.getElementById("edit-text").value = "";
        document.getElementById("edit-ip").value = "";
        document.getElementById("modal-title").textContent = "Create node";
        document.getElementById("delete-confirm").style.display = "none";
        setModeUI("create");
        editState.nodeId = null;
        editState.mode = "create";
        editState.position = position || null;
        updateFieldVisibility();
        setOverlayOpen(true);
      }

      document.getElementById("edit-type").addEventListener("change", updateFieldVisibility);
      document.getElementById("modal-close").addEventListener("click", () => {
        setOverlayOpen(false);
        editState.nodeId = null;
      });
      document.getElementById("modal-cancel").addEventListener("click", () => {
        setOverlayOpen(false);
        editState.nodeId = null;
      });
      document.getElementById("modal-save").addEventListener("click", () => {
        if (!editState.nodeId) return;
        const nodeId = editState.nodeId;
        const nodeType = document.getElementById("edit-type").value;
        const payload = {
          event: "edit_save",
          ts: Date.now(),
          node_id: nodeId,
          node_type: nodeType,
          name: getNameValue(),
          ip: nodeType === "domain" || nodeType === "text" ? "" : document.getElementById("edit-ip").value,
          floor: document.getElementById("edit-floor").value,
        };
        setOverlayOpen(false);
        setComponentValue(payload);
        editState.nodeId = null;
      });
      document.getElementById("modal-create").addEventListener("click", () => {
        if (!editState.position) return;
        const nodeType = document.getElementById("edit-type").value;
        const payload = {
          event: "create_save",
          ts: Date.now(),
          node_type: nodeType,
          name: getNameValue(),
          ip: nodeType === "domain" || nodeType === "text" ? "" : document.getElementById("edit-ip").value,
          floor: document.getElementById("edit-floor").value,
          position: editState.position,
        };
        setOverlayOpen(false);
        setComponentValue(payload);
        editState.position = null;
      });
      document.getElementById("modal-delete").addEventListener("click", () => {
        if (!editState.nodeId) return;
        const nodeId = editState.nodeId;
        setOverlayOpen(false);
        setComponentValue({ event: "delete_confirm", ts: Date.now(), node_id: nodeId });
        editState.nodeId = null;
      });

      window.addEventListener("message", (event) => {
        const data = event.data;
        if (!data || !data.type) {
          return;
        }
        if (data.type === "streamlit:render") {
          render(data.args);
        }
      });

      window.addEventListener("resize", () => {
        if (lastArgs && lastArgs.elements) {
          render(lastArgs);
        }
      });

      sendMessage("streamlit:componentReady", { apiVersion: 1 });
      setFrameHeight(800);
    </script>
  </body>
</html>
